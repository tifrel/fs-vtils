package fsv

const (
	no_FILE_OPERATION uint = 1 + iota
	no_INVALID_FLAG
	no_MISSING_TARGETDIR
	no_MISSING_REC_FLAG
	no_MISSING_OS_SUPPORT
	no_NO_COMMON_DIR
	no_OCCUPIED_PATH
	no_UNKNOWN_ERR
)

const (
	_FLAG_EMPTY rune = 0
	_PATH_EMPTY Path = ""
)

// Error is the type for any error generated by this package. If an error
// returned by functions from this package are not of type fsv.Error, it has
// been fast-forwarded.
type Error struct {
	Id   uint
	Path Path
	Flag rune
}

// These are the error prototypes
var (
	FILE_OPERATION     = Error{no_FILE_OPERATION, _PATH_EMPTY, _FLAG_EMPTY}
	INVALID_FLAG       = Error{no_INVALID_FLAG, _PATH_EMPTY, _FLAG_EMPTY}
	MISSING_OS_SUPPORT = Error{no_MISSING_OS_SUPPORT, _PATH_EMPTY, _FLAG_EMPTY}
	MISSING_REC_FLAG   = Error{no_MISSING_REC_FLAG, _PATH_EMPTY, _FLAG_EMPTY}
	MISSING_TARGETDIR  = Error{no_MISSING_TARGETDIR, _PATH_EMPTY, _FLAG_EMPTY}
	NO_COMMON_DIR      = Error{no_NO_COMMON_DIR, _PATH_EMPTY, _FLAG_EMPTY}
	OCCUPIED_PATH      = Error{no_OCCUPIED_PATH, _PATH_EMPTY, _FLAG_EMPTY}
	UNKNOWN_ERR        = Error{no_UNKNOWN_ERR, _PATH_EMPTY, _FLAG_EMPTY}
)

var ownErrs = []Error{
	FILE_OPERATION,
	INVALID_FLAG,
	MISSING_OS_SUPPORT,
	MISSING_REC_FLAG,
	MISSING_TARGETDIR,
	OCCUPIED_PATH,
	UNKNOWN_ERR,
}

func (e Error) Error() string {
	switch e.Id {
	case no_FILE_OPERATION:
		return "File-only operation on non-file: " + string(e.Path)

	case no_INVALID_FLAG:
		return "Invalid flag: " + string(e.Flag)

	case no_MISSING_TARGETDIR:
		return "Inexistent target directory: " + string(e.Path)

	case no_MISSING_REC_FLAG:
		return "Copying/Moving dir requires recursive flag."

	case no_MISSING_OS_SUPPORT:
		return "Operating system does not support this operation."

	case no_NO_COMMON_DIR:
		return "No common directory found."

	case no_OCCUPIED_PATH:
		return "Occupied path: " + string(e.Path)

	case no_UNKNOWN_ERR:
		return "Unkown error."

	default:
		panic("Tried to call Error() on unidentifiable error :(")
	}

}

func (proto Error) new(path Path, flag rune) Error {
	return Error{
		proto.Id,
		path,
		flag,
	}
}

// IsTypeOf determines wether an error (as defined by the interface) is of type
// fsv.Error and wether both errors have the same prototype. The prototype
// comparison is handled via the ID. Also returns true if both errors are nil.
func (proto Error) IsTypeOf(e error) bool {
	switch {
	case e == nil && error(proto) == nil:
		return true
	case e != nil && error(proto) == nil:
		return false
	case e == nil && error(proto) != nil:
		return false
	}

	fsve, ok := e.(Error)
	if !ok {
		return false
	}

	if fsve.Id == proto.Id {
		return true
	}
	return false
}

func IsFSVErr(e error) bool {
	for _, proto := range ownErrs {
		if proto.IsTypeOf(e) {
			return true
		}
	}
	return false
}

// ErrorList is a specific kind of error for the PathList.Each() method. If it
// does not encounter an error, it returns nil. Otherwise it return a slice of
// errors, matching with the indices of the Paths in PathList.
type ErrorList []error

// Error method, so that the ErrorList itself satisfies the error interface.
func (errs ErrorList) Error() string {
	msg := ""
	for i, err := range errs {
		msg += string(i) + ": " + err.Error()
	}
	return msg
}

// to return nil if all errors inside are nil
func (errs ErrorList) errorize() error {
	rErrs := ErrorList(make([]error, len(errs)))
	isNil := true
	for i, err := range errs {
		if err != nil {
			isNil = false
			rErrs[i] = err
		}
	}

	if isNil {
		return nil
	}
	return rErrs
}
